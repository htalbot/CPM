// -*- C++ -*- generated by wxGlade 0.6.5 on Fri Oct 12 15:26:48 2012 from "C:\dpo\core\trunk\tools\templates\layer\wxWidgets\src\CPMG.wxg"

#include "ACEWin64Warnings/BeginSuppressWarnings.h"
#include "ace/Process.h"
#include "ace/Date_Time.h"
#include "ACEWin64Warnings/EndSuppressWarnings.h"
#include "CPMGFrame.h"
#include "wxids.h"
#include "CPMCore/CPMUtils.h"
#include "ProcessDlg.h"
#include "NodeDlg.h"
#include "CPMCore/CPMAppLayer.h"
#include "EnvVarExpand/EnvVarExpand.h"

const std::string show_objects_string("Show objects");
const std::string hide_objects_string("Hide objects");

// begin wxGlade: ::extracode
// end wxGlade


wxColour color_disabled = wxColour(200, 200, 200);
wxColour color_unavailable = wxColour(255, 190, 190);
wxColour color_available = wxColor(255, 255, 255);
wxColour color_object = wxColor(255, 255, 220);

CPMGFrame::CPMGFrame(wxWindow* parent,
                        int id,
                        const wxString& title,
                        const wxPoint& pos,
                        const wxSize& size,
                        long style)
: wxFrame(parent, id, title, pos, size, wxDEFAULT_FRAME_STYLE)
, refresh_objects_(false)
, show_objects_(true)
, cpmd_connection_test_done_once_(false)
, console_("CPMG", 120, 40)
{
    style;

    // begin wxGlade: CPMGFrame::CPMGFrame
    window_1 = new wxSplitterWindow(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D|wxSP_BORDER);
    window_1_pane_plugins = new wxPanel(window_1, wxID_ANY);
    notebook_processes = new wxNotebook(window_1_pane_plugins, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    notebook_1_pane_1 = new wxPanel(notebook_processes, wxID_ANY);
    window_2 = new wxSplitterWindow(notebook_1_pane_1, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D|wxSP_BORDER);
    window_2_pane_msg = new wxPanel(window_2, wxID_ANY);
    window_2_pane_processes = new wxPanel(window_2, wxID_ANY);
    window_1_pane_nodes = new wxPanel(window_1, wxID_ANY);
    sizer_10_staticbox = new wxStaticBox(this, wxID_ANY, _("Shutdown"));
    sizer_5_staticbox = new wxStaticBox(this, wxID_ANY, _("Consoles"));
    sizer_9_staticbox = new wxStaticBox(this, wxID_ANY, _("Boot"));
    button_boot_cpm = new wxButton(this, wxID_HIGHEST + wxID_button_boot_cpm, _("Boot CPM"));
    checkbox_overwrite_auto_start_to_false = new wxCheckBox(this, wxID_ANY, _("Overwrite autostart to false"));
    button_shutdown_cpmm = new wxButton(this, wxID_HIGHEST + wxID_button_shutdown_cpmm, _("Shutdown CPMM"));
    button_shutdown_cpmd = new wxButton(this, wxID_HIGHEST + wxID_button_shutdown_cpmd, _("Shutdown CPMD"));
    checkbox_console_cpmm = new wxCheckBox(this, wxID_ANY, _("CPMM"));
    checkbox_console_cpmd = new wxCheckBox(this, wxID_ANY, _("CPMD"));
    checkbox_cpmg = new wxCheckBox(this, wxID_ANY, _("CPMG"));
    tree_ctrl_nodes = new wxTreeCtrl(window_1_pane_nodes, wxID_HIGHEST + wxID_tree, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_MULTIPLE|wxTR_MULTIPLE|wxTR_EXTENDED|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    button_set_as_default = new wxButton(window_1_pane_nodes, wxID_HIGHEST + wxID_button_set_as_default, _("Set as default"), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
    button_save = new wxButton(window_1_pane_nodes, wxID_HIGHEST + wxID_button_save, _("Save"), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
    button_save_as = new wxButton(window_1_pane_nodes, wxID_HIGHEST + wxID_button_save_as, _("Save as..."), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
    button_load = new wxButton(window_1_pane_nodes, wxID_HIGHEST + wxID_button_load, _("Load..."), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
    button_show_objects = new wxButton(window_1_pane_nodes, wxID_HIGHEST + wxID_button_refresh, _("ShowObjects"));
    grid_processes = new wxGrid(window_2_pane_processes, wxID_ANY);
    const wxString *list_box_msg_choices = NULL;
    list_box_msg = new wxListBox(window_2_pane_msg, wxID_HIGHEST + wxID_list_msg, wxDefaultPosition, wxDefaultSize, 0, list_box_msg_choices, wxLB_EXTENDED|wxLB_HSCROLL);
    button_clear_msg = new wxButton(window_2_pane_msg, wxID_ANY, _("Clear messages"));

    set_properties();
    do_layout();
    // end wxGlade

    m_pTimer = new wxTimer(this,TIMER_SVC);
    
    button_show_objects->SetLabel(show_objects_string);

    if (CPMUtils_ns::CPMUtils::load_cpm_params(show_cpmm_console_init_, show_cpmd_console_init_, overwrite_autostart_to_false_))
    {
        checkbox_console_cpmm->SetValue(show_cpmm_console_init_);
        checkbox_console_cpmd->SetValue(show_cpmd_console_init_);
        checkbox_overwrite_auto_start_to_false->SetValue(overwrite_autostart_to_false_);
    }

    checkbox_cpmg->Show(false); // Not useful (listctrl is used instead)

    int w, h;
    this->GetSize(&w, &h);

    window_1->SetMinimumPaneSize(50);
    window_1->SetSashPosition(0.50 * w);

    window_2->SetMinimumPaneSize(50);
    window_2->SetSashPosition(0.50 * h);

    SetIcon(wxICON(cpm_icon));
}


BEGIN_EVENT_TABLE(CPMGFrame, wxFrame)
    // begin wxGlade: CPMGFrame::event_table
    EVT_BUTTON(wxID_HIGHEST + wxID_button_boot_cpm, CPMGFrame::on_button_boot_cpm)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_shutdown_cpmm, CPMGFrame::on_button_shutdown_cpmm)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_shutdown_cpmd, CPMGFrame::on_button_shutdown_cpmd)
    EVT_CHECKBOX(wxID_ANY, CPMGFrame::on_checkbox_cpmg)
    EVT_TREE_SEL_CHANGED(wxID_HIGHEST + wxID_tree, CPMGFrame::on_sel_changed)
    EVT_TREE_KEY_DOWN(wxID_HIGHEST + wxID_tree, CPMGFrame::on_tree_key_down)
    EVT_TREE_END_LABEL_EDIT(wxID_HIGHEST + wxID_tree, CPMGFrame::on_tree_end_label_edit)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_set_as_default, CPMGFrame::on_button_set_as_default)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_save, CPMGFrame::on_button_save)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_save_as, CPMGFrame::on_button_save_as)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_load, CPMGFrame::on_button_load)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_refresh, CPMGFrame::on_button_show_objects)
    EVT_GRID_CMD_CELL_CHANGE(wxID_ANY, CPMGFrame::on_cell_changed_grid_procs)
    EVT_BUTTON(wxID_ANY, CPMGFrame::on_button_clear_msg)
    // end wxGlade

    // wxGlade forgot to generate them...
    EVT_TREE_ITEM_RIGHT_CLICK(wxID_HIGHEST + wxID_tree, CPMGFrame::on_tree_item_right_click)
    EVT_MENU(POPUP_NEW_NODE, CPMGFrame::on_new_node)
    EVT_MENU(POPUP_NEW_PROCESS, CPMGFrame::on_new_process)
    EVT_MENU(POPUP_START, CPMGFrame::on_start)
    EVT_MENU(POPUP_STOP, CPMGFrame::on_stop)
    EVT_MENU(POPUP_SHOW_CONSOLE, CPMGFrame::on_show_console)
    EVT_MENU(POPUP_HIDE_CONSOLE, CPMGFrame::on_hide_console)
    EVT_MENU(POPUP_ENABLE, CPMGFrame::on_enable)
    EVT_MENU(POPUP_DISABLE, CPMGFrame::on_disable)
    EVT_MENU(POPUP_REMOVE, CPMGFrame::on_remove)
    EVT_MENU(POPUP_PIDS, CPMGFrame::on_pids)
    EVT_MENU(POPUP_GET_VERSION, CPMGFrame::on_get_version)
    EVT_BUTTON(wxID_HIGHEST + wxID_button_refresh, CPMGFrame::on_refresh)
    EVT_CLOSE(CPMGFrame::on_close)
    EVT_TIMER(TIMER_SVC,CPMGFrame::OnTimerTimeout)
END_EVENT_TABLE();


// wxGlade: add CPMGFrame event handlers


void CPMGFrame::set_properties()
{
    // begin wxGlade: CPMGFrame::set_properties
    SetTitle(_("CPM"));
    checkbox_overwrite_auto_start_to_false->SetValue(1);
    grid_processes->CreateGrid(10, 4);
    grid_processes->SetColLabelValue(0, _("Process ID"));
    grid_processes->SetColLabelValue(1, _("Env. Var. ID"));
    grid_processes->SetColLabelValue(2, _("Module name"));
    grid_processes->SetColLabelValue(3, _("Port number"));
    list_box_msg->SetMinSize(wxSize(425, 181));
    // end wxGlade

    // Override values that may be set by wxGlade
    //window_1_pane_nodes->SetMinSize(wxSize(300, 550));
    //window_1_pane_plugins->SetMinSize(wxSize(600, 550));
    //window_2_pane_processes->SetMinSize(wxSize(300, 300));
    //window_2_pane_processes->SetMinSize(wxSize(300, 200));
    window_1_pane_nodes->SetSize(wxSize(300, 550));
    window_1_pane_plugins->SetSize(wxSize(600, 550));
    window_2_pane_processes->SetSize(wxSize(300, 300));
    window_2_pane_processes->SetSize(wxSize(300, 200));

    grid_processes->HideRowLabels();
}


void CPMGFrame::do_layout()
{
    // begin wxGlade: CPMGFrame::do_layout
    wxBoxSizer* sizer_1 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_3 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_11 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_14 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_13 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_2 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_4 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_7 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_basic_actions = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_8 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_22 = new wxBoxSizer(wxHORIZONTAL);
    sizer_5_staticbox->Lower();
    wxStaticBoxSizer* sizer_5 = new wxStaticBoxSizer(sizer_5_staticbox, wxHORIZONTAL);
    wxBoxSizer* sizer_6 = new wxBoxSizer(wxHORIZONTAL);
    sizer_10_staticbox->Lower();
    wxStaticBoxSizer* sizer_10 = new wxStaticBoxSizer(sizer_10_staticbox, wxHORIZONTAL);
    sizer_9_staticbox->Lower();
    wxStaticBoxSizer* sizer_9 = new wxStaticBoxSizer(sizer_9_staticbox, wxHORIZONTAL);
    sizer_9->Add(button_boot_cpm, 0, wxRIGHT, 5);
    sizer_9->Add(checkbox_overwrite_auto_start_to_false, 0, wxALIGN_CENTER_VERTICAL, 0);
    sizer_6->Add(sizer_9, 1, wxEXPAND|wxALIGN_RIGHT, 5);
    sizer_10->Add(button_shutdown_cpmm, 0, wxRIGHT, 5);
    sizer_10->Add(button_shutdown_cpmd, 0, 0, 0);
    sizer_6->Add(sizer_10, 0, wxLEFT|wxEXPAND, 5);
    sizer_22->Add(sizer_6, 0, wxRIGHT|wxEXPAND, 5);
    sizer_22->Add(20, 20, 1, 0, 0);
    sizer_5->Add(checkbox_console_cpmm, 0, wxRIGHT, 5);
    sizer_5->Add(checkbox_console_cpmd, 0, 0, 0);
    sizer_5->Add(checkbox_cpmg, 0, 0, 0);
    sizer_22->Add(sizer_5, 0, wxALIGN_CENTER_VERTICAL, 0);
    sizer_1->Add(sizer_22, 0, wxALL|wxEXPAND, 5);
    sizer_8->Add(tree_ctrl_nodes, 1, wxEXPAND, 0);
    sizer_2->Add(sizer_8, 1, wxEXPAND, 0);
    sizer_basic_actions->Add(button_set_as_default, 0, wxALL, 3);
    sizer_basic_actions->Add(button_save, 0, wxALL, 3);
    sizer_basic_actions->Add(button_save_as, 0, wxALL, 3);
    sizer_basic_actions->Add(button_load, 0, wxALL, 3);
    sizer_4->Add(sizer_basic_actions, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    sizer_4->Add(button_show_objects, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 3);
    sizer_4->Add(sizer_7, 0, wxEXPAND|wxALIGN_CENTER_HORIZONTAL, 0);
    sizer_2->Add(sizer_4, 0, wxEXPAND, 0);
    window_1_pane_nodes->SetSizer(sizer_2);
    sizer_13->Add(grid_processes, 1, wxEXPAND, 0);
    window_2_pane_processes->SetSizer(sizer_13);
    sizer_14->Add(list_box_msg, 1, wxEXPAND, 0);
    sizer_14->Add(button_clear_msg, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    window_2_pane_msg->SetSizer(sizer_14);
    window_2->SplitHorizontally(window_2_pane_processes, window_2_pane_msg);
    sizer_11->Add(window_2, 1, wxEXPAND, 0);
    notebook_1_pane_1->SetSizer(sizer_11);
    notebook_processes->AddPage(notebook_1_pane_1, _("Processes"));
    sizer_3->Add(notebook_processes, 1, wxEXPAND, 0);
    window_1_pane_plugins->SetSizer(sizer_3);
    window_1->SplitVertically(window_1_pane_nodes, window_1_pane_plugins);
    sizer_1->Add(window_1, 1, wxALL|wxEXPAND, 5);
    SetSizer(sizer_1);
    sizer_1->Fit(this);
    Layout();
    // end wxGlade
}

void CPMGFrame::set_title(const std::string & file)
{
    std::string default_settings_file;
    CPMUtils_ns::CPMUtils::get_default_cpmm_settings_file(default_settings_file);

    std::string default_flag;

    if (file == default_settings_file)
    {
        default_flag = " (default)";
    }

    std::string change_flag;
    if (local_settings_changed())
    {
        change_flag = " *";
    }

    wxString title = wxString::Format(
                        "CPM - %s%s%s",
                        file.c_str(),
                        default_flag.c_str(),
                        change_flag.c_str());

    this->SetTitle(title);
}

bool CPMGFrame::load_settings(
        ::ICPM_module::CPMMSettings & cpmm_initial_settings,
        ::ICPM_module::CPMMSettings & cpmm_current_settings,
        std::string & file)
{
    std::string path;
    if (!CPMUtils_ns::CPMUtils::get_cpmm_settings_path(path))
    {
        wxMessageBox(
            "Can't get CPMM settings path",
            "Loading CPMM settings",
            wxOK | wxICON_ERROR);
        return false;
    }

    wxFileDialog dlg(this);
    dlg.SetDirectory(path.c_str());

    if (dlg.ShowModal() == wxID_OK)
    {
        file = dlg.GetPath().c_str();

        if (!CPMUtils_ns::CPMUtils::get_cpmm_settings_from_file(
                            file.c_str(),
                            cpmm_current_settings))
        {
            wxString msg = wxString::Format(
                                "Can't convert file '%s' to settings",
                                file.c_str());
            wxMessageBox(
                msg,
                "Loading CPMM settings",
                wxOK | wxICON_ERROR);
            return false;
        }

        CPMUtils_ns::CPMUtils::backslash_to_slash(file);

        cpmm_initial_settings = cpmm_current_settings;

        // Set window title with the name of the config file
        set_title(file);
    }

    return true;
}

void CPMGFrame::fill_tree(
        const ICPM_module::CPMMSettings & settings,
        bool reset_show_objects)
{
    list_box_msg->SetBackgroundColour(color_available);

    tree_ctrl_nodes->DeleteAllItems();
    int rows_count = grid_processes->GetNumberRows();
    if (rows_count)
    {
        grid_processes->DeleteRows(0, grid_processes->GetNumberRows());
    }

    std::string config_id;
    wxTreeItemId root_item;
    try
    {
        // Set config_id
        config_id = settings.settings_id.operator const CORBA::Char *();
        root_item = tree_ctrl_nodes->AddRoot(config_id.c_str());
    }
    catch(...)
    {
        root_item = tree_ctrl_nodes->AddRoot("CPMM unreachable");
        tree_ctrl_nodes->SetItemBackgroundColour(root_item, color_unavailable);
        return;
    }

    // nodes
    for (::CORBA::ULong i = 0; i != settings.nodes.length(); i++)
    {
        ICPM_module::NodeDef node_def = settings.nodes[i];
        std::string node_id = node_def.node_id.operator const CORBA::Char *();
        wxTreeItemId node_item = tree_ctrl_nodes->AppendItem(root_item, node_id.c_str());

        if (!node_def.enabled)
        {
            tree_ctrl_nodes->SetItemBackgroundColour(node_item, color_disabled);
        }

        // processes
        ICPM_module::ProcessSeq procs = node_def.processes;
        for (::CORBA::ULong j = 0; j != procs.length(); j++)
        {
            ICPM_module::ProcessDef proc = procs[j];

            std::string process_id(proc.process_id.operator const CORBA::Char *());
            std::string module_name(proc.module_name.operator const CORBA::Char *());

            std::string entry = process_id + " (" + module_name + ")";
            wxTreeItemId item = tree_ctrl_nodes->AppendItem(node_item, entry.c_str());
            if (!proc.enabled
                || !node_def.enabled)
            {
                tree_ctrl_nodes->SetItemBackgroundColour(item, color_disabled);
            }

            // Objects
            if (refresh_objects_)
            {
                if (node_def.enabled)
                {
                    bool fill_with_objects(true);

                    static bool last_started_status(false);
                    static ICPM_module::UnavailableElementIDSeq last_nodes;
                    static ICPM_module::UnavailableElementIDSeq last_processes;

                    ICPM_module::UnavailableElementIDSeq nodes(last_nodes);
                    ICPM_module::UnavailableElementIDSeq processes(last_processes);

                    bool started;
                    if (!get_cpmm_started_status(started))
                    {
                        started = last_started_status;
                    }

                    if (started)
                    {
                        if (get_unavailable(nodes, processes))
                        {
                            last_nodes = nodes;
                            last_processes = processes;
                        }

                        for (CORBA::ULong i = 0; i != nodes.length(); i++)
                        {
                            std::string unavailable_node = nodes[i].element_id.operator const CORBA::Char *();
                            std::string node_def_id = node_def.node_id.operator const CORBA::Char *();
                            if (unavailable_node == node_def_id)
                            {
                                fill_with_objects = false;
                                break;
                            }
                        }

                        for (CORBA::ULong i = 0; i != last_processes.length(); i++)
                        {
                            std::string unavail_proc_id = last_processes[i].element_id.operator const CORBA::Char *();
                            size_t pos = unavail_proc_id.find(':');
                            if (pos != std::string::npos)
                            {
                                unavail_proc_id = unavail_proc_id.substr(pos + 1);
                            }
                            if (unavail_proc_id == process_id)
                            {
                                fill_with_objects = false;
                                break;
                            }
                        }

                        if (fill_with_objects)
                        {
                            // Objects
                            fill_processes_with_objects_ids(proc, item);
                        }
                    }
                }
            }
        }
    }

    tree_ctrl_nodes->ExpandAll();

    set_widgets_status();

    tree_ctrl_nodes->UnselectAll();

    tree_ctrl_nodes->EnsureVisible(root_item);

    if (reset_show_objects)
    {
        hide_objects();
        button_show_objects->SetLabel(show_objects_string.c_str());
        show_objects_ = true;
    }
}

bool CPMGFrame::fill_processes_with_objects_ids(
            ICPM_module::ProcessDef & proc,
            wxTreeItemId & proc_item)
{
    if (proc.enabled)
    {
        std::string node_id = proc.node_id.operator const CORBA::Char *();
        std::string proc_id = proc.process_id.operator const CORBA::Char *();
        std::string port_number = proc.port_number.operator const CORBA::Char *();

        std::string obj_id = proc_id;

        std::string location = std::string("corbaloc:iiop:") + node_id + ":" + port_number + "/" + obj_id;

        if (!EnvVarExpand_ns::EnvVarExpand::expand_env_variables(location, location))
        {
            report("failed to expand environment variable '%s'", location.c_str());
            return false;
        }

        if (CPMUtils_ns::CPMUtils::ping(node_id))
        {
            CPMTAOLayer::GetRefStatus status;
            ::ICPM_module::ICPMProcess_var cpmo = CPMTAOLAYER->get_ref_from_iortable<::ICPM_module::ICPMProcess>(location.c_str(), status);
            if (!cpmo)
            {
                //report("Can't get reference on %s", location.c_str());
                return false;
            }

            try
            {
                ::ICPM_module::ObjectDescSeq_var objs_ids;
                cpmo->object_list(objs_ids);
                for (int i = 0; i != objs_ids->length(); i++)
                {
                    std::string obj_id =  objs_ids->operator[](i).object_id.operator const CORBA::Char *();
                    //size_t pos = obj_id.find(":");
                    //if (pos != std::string::npos)
                    //{
                    //    obj_id = obj_id.substr(pos + 1);
                    //}
                    wxTreeItemId obj_item = tree_ctrl_nodes->AppendItem(proc_item, obj_id.c_str());
                    tree_ctrl_nodes->SetItemBackgroundColour(obj_item, color_object);
                }
            }
            catch(...)
            {
                report("Can't get object list from %s", location.c_str());
                return false;
            }
        }
        else
        {
            report("Can't access %s when getting references on objects", node_id.c_str());
        }
    }

    return true;
}

void CPMGFrame::fill_processes_list(const std::string & node_id_in)
{
    int rows_count = grid_processes->GetNumberRows();
    if (rows_count)
    {
        grid_processes->DeleteRows(0, rows_count);
    }

    for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
    {
        ICPM_module::NodeDef node_def = current_settings_.nodes[i];
        std::string node_id = node_def.node_id.operator const CORBA::Char *();

        if (node_id == node_id_in)
        {
            // processes
            ICPM_module::ProcessSeq procs = node_def.processes;

            grid_processes->AppendRows(procs.length());

            for (::CORBA::ULong j = 0; j != procs.length(); j++)
            {
                ICPM_module::ProcessDef proc = procs[j];
                std::string process_id = proc.process_id.operator const CORBA::Char *();
                std::string env_var_id = proc.env_var_id.operator const CORBA::Char *();
                std::string module_name = proc.module_name.operator const CORBA::Char *();
                std::string port_number = proc.port_number.operator const CORBA::Char *();

                grid_processes->SetCellValue(j, 0, process_id.c_str());
                grid_processes->SetCellValue(j, 1, env_var_id.c_str());
                grid_processes->SetCellValue(j, 2, module_name.c_str());
                grid_processes->SetCellValue(j, 3, port_number.c_str());
            }
        }
    }

    grid_processes->HideRowLabels();
    grid_processes->AutoSizeColumns();
}

ICPM_module::ProcessSeq CPMGFrame::get_selected_procs()
{
    wxTreeItemId root = tree_ctrl_nodes->GetRootItem();

    // Selected items.
    wxArrayTreeItemIds items;
    tree_ctrl_nodes->GetSelections(items);

    // Processes to pass to CPMM.
    std::list<ICPM_module::ProcessDef> procs;

    // Iterate over all selected items to find processes to pass to CPMM.
    for (unsigned int i = 0; i != items.GetCount(); i++)
    {
        wxTreeItemId selected_item = items[i];

        wxString selected_item_id = tree_ctrl_nodes->GetItemText(selected_item);

        if (selected_item == root)
        {
            // Keep in procs all processes on all nodes.

            for (::CORBA::ULong j = 0; j != current_settings_.nodes.length(); j++)
            {
                ICPM_module::NodeDef node = current_settings_.nodes[j];
                for (::CORBA::ULong k = 0; k != node.processes.length(); k++)
                {
                    procs.push_back(node.processes[k]);
                }
            }
        }
        else
        {
            wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(selected_item);

            if (parent == root) // the selected item is a node
            {
                // Keep in procs all processes on the selected node.

                wxString selected_node_id = tree_ctrl_nodes->GetItemText(selected_item);

                // Find the selected node among current_settings_ and assign its processes to procs.
                for (::CORBA::ULong j = 0; j != current_settings_.nodes.length(); j++)
                {
                    ICPM_module::NodeDef node = current_settings_.nodes[j];

                    std::string node_id = node.node_id.operator const CORBA::Char *();

                    if (node_id == selected_node_id)
                    {
                        for (::CORBA::ULong k = 0; k != node.processes.length(); k++)
                        {
                            procs.push_back(node.processes[k]);
                        }
                        break; // Don't process others.
                    }
                }
            }
            else
            {
                wxTreeItemId parent_of_parent = tree_ctrl_nodes->GetItemParent(parent);

                if (parent_of_parent == root)
                {
                    // the selected item is a process

                    // Keep in procs all selected processes
                    wxString selected_node_id = tree_ctrl_nodes->GetItemText(parent);

                    for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
                    {
                        ICPM_module::NodeDef node = current_settings_.nodes[i];

                        std::string node_id = node.node_id.operator const CORBA::Char *();

                        if (node_id == selected_node_id)
                        {
                            ICPM_module::ProcessSeq node_procs = node.processes;
                            for (::CORBA::ULong j = 0; j != node_procs.length(); j++)
                            {
                                ICPM_module::ProcessDef proc = node_procs[j];

                                wxString process_id(proc.process_id.operator const CORBA::Char *());

                                size_t pos = selected_item_id.find('(');
                                selected_item_id = selected_item_id.substr(0, pos - 1);
                                if (process_id == selected_item_id)
                                {
                                    procs.push_back(proc);
                                }
                            }
                        }
                    }
                }
                else
                {
                    // The selected item is an object
                }
            }
        }
    }

    ICPM_module::ProcessSeq proc_seq;
    proc_seq.length(CORBA::ULong(procs.size()));

    long i(0);
    std::list<ICPM_module::ProcessDef>::iterator it;
    for (it = procs.begin(); it != procs.end(); it++)
    {
        //std::string node_id = it->node_id.operator const CORBA::Char *();
        //std::string process_id = it->process_id.operator const CORBA::Char *();
        //wxLogDebug("proc: %s (noeud = %s)", process_id.c_str(), node_id.c_str());
        proc_seq[i++] = *it;
    }

    return proc_seq;
}

std::map<std::string, std::list<std::string> > CPMGFrame::get_selected_objects()
{
    std::map<std::string, std::list<std::string> > objects_ids;
    //          map[node_id] = (proc1:obj1, proc2:obj2, ...)

    // Selected items.
    wxArrayTreeItemIds items;
    size_t selected_items_count = tree_ctrl_nodes->GetSelections(items);

    for (size_t i = 0; i != selected_items_count; i++)
    {
        wxTreeItemId selected_item = items[i];
        wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(selected_item);
        wxTreeItemId parent_parent = tree_ctrl_nodes->GetItemParent(parent);

        std::string node_id = tree_ctrl_nodes->GetItemText(parent_parent);
        std::string process_id = tree_ctrl_nodes->GetItemText(parent);

        size_t pos = process_id.find("(");
        if (pos != std::string::npos)
        {
            process_id = process_id.substr(0, pos - 1);
        }

        std::string object_id = tree_ctrl_nodes->GetItemText(selected_item);

        objects_ids[node_id].push_back(process_id + ":" + object_id);
    }

    return objects_ids;
}

void CPMGFrame::enable(bool flag)
{
    wxTreeItemId root = tree_ctrl_nodes->GetRootItem();

    wxArrayTreeItemIds items;
    tree_ctrl_nodes->GetSelections(items);

    for (unsigned int i = 0; i != items.GetCount(); i++)
    {
        wxTreeItemId selected_item = items[i];
        wxString selected_item_id = tree_ctrl_nodes->GetItemText(selected_item);

        wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(selected_item);
        if (parent == root)
        {
            // node
            for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
            {
                std::string node_id = current_settings_.nodes[i].node_id;
                if (node_id == selected_item_id)
                {
                    current_settings_.nodes[i].enabled = flag;
                    for (::CORBA::ULong j = 0; j != current_settings_.nodes[i].processes.length(); j++)
                    {
                        current_settings_.nodes[i].processes[j].enabled = flag;
                    }
                    continue;
                }
            }
        }
        else
        {
            // process
            wxString parent_id = tree_ctrl_nodes->GetItemText(parent);
            for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
            {
                bool found(false);
                ICPM_module::NodeDef node = current_settings_.nodes[i];
                std::string node_id = node.node_id;
                if (node_id == parent_id)
                {
                    for (::CORBA::ULong j = 0; j != node.processes.length(); j++)
                    {
                        ICPM_module::ProcessDef proc = node.processes[j];

                        std::string proc_id = proc.process_id.operator const CORBA::Char *();

                        size_t pos = selected_item_id.find('(');
                        selected_item_id = selected_item_id.substr(0, pos - 1);

                        if (proc_id == selected_item_id)
                        {
                            current_settings_.nodes[i].processes[j].enabled = flag;
                            found = true;
                            break;
                        }
                    }
                }
                if (found)
                {
                    break;
                }
            }
        }
    }

    cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_);
}

void CPMGFrame::set_widgets_status()
{
    std::string default_settings_file;
    CPMUtils_ns::CPMUtils::get_default_cpmm_settings_file(default_settings_file);

    set_title(default_settings_file);

    bool started;
    if (get_cpmm_started_status(started) && started)
    {
        button_load->Enable(false);
    }
    else
    {
        button_load->Enable(true);
    }
}

bool CPMGFrame::node_unavailable(const std::string & node_id,
                                ICPM_module::UnavailableElementIDSeq & nodes)
{
    for (::CORBA::ULong i = 0; i != nodes.length(); i++)
    {
        std::string unavail_node_id = nodes[i].element_id.operator const CORBA::Char *();

        if (node_id == unavail_node_id)
        {
            return true;
        }
    }

    return false;
}

bool CPMGFrame::process_unavailable(
    const std::string & node_id,
    const std::string & proc_id,
    ICPM_module::UnavailableElementIDSeq & processes)
{
    for (::CORBA::ULong i = 0; i != processes.length(); i++)
    {
        std::string long_proc_id = processes[i].element_id.operator const CORBA::Char *();

        size_t pos = long_proc_id.find(':');
        std::string unavail_node_id = long_proc_id.substr(0, pos);
        std::string unavail_proc_id = long_proc_id.substr(pos + 1);

        if (node_id == unavail_node_id
            && proc_id == unavail_proc_id)
        {
            return true;
        }
    }

    return false;
}

void CPMGFrame::start(wxCommandEvent &)
{
    if (CORBA::is_nil(cpmm_obj_))
    {
        return;
    }

    ICPM_module::ProcessSeq proc_seq = get_selected_procs();

    try
    {
        cpmm_obj_->start(proc_seq);
    }
    catch(...)
    {
        wxMessageBox(
            "Exception",
            "Starting",
            wxOK | wxICON_INFORMATION);
    }
}

void CPMGFrame::stop(const ICPM_module::ProcessSeq & proc_seq)
{
    if (CORBA::is_nil(cpmm_obj_))
    {
        return;
    }

    try
    {
        cpmm_obj_->stop(proc_seq);
    }
    catch(...)
    {
        wxMessageBox(
            "Exception",
            "Stop",
            wxOK | wxICON_INFORMATION);
    }
}

void CPMGFrame::show_console(const ICPM_module::ProcessSeq & proc_seq, bool show)
{
    if (CORBA::is_nil(cpmm_obj_))
    {
        return;
    }

    try
    {
        cpmm_obj_->show_console(proc_seq, show);
    }
    catch(...)
    {
        wxMessageBox(
            "Exception",
            "Stop",
            wxOK | wxICON_INFORMATION);
    }
}

bool CPMGFrame::cpmm_update_settings(
            const ICPM_module::CPMMSettings & initial_settings,
            const ICPM_module::CPMMSettings & current_settings,
            const std::string & file)
{
    if (CORBA::is_nil(cpmm_obj_))
    {
        return false;
    }

    try
    {
        cpmm_obj_->update_settings(initial_settings, current_settings, file.c_str());
        set_title(current_settings_file_);
    }
    catch(...)
    {
        wxMessageBox("Failed to update enabled flag!",
                        "Settings",
                        wxOK | wxICON_ERROR);
        return false;
    }

    return true;
}

bool CPMGFrame::settings_changed(
                const ICPM_module::CPMMSettings & initial_settings,
                const ICPM_module::CPMMSettings & current_settings)
{
    std::string settings_id_init = initial_settings.settings_id.operator const CORBA::Char *();
    std::string settings_id = current_settings.settings_id.operator const CORBA::Char *();
    if (settings_id_init != settings_id)
    {
        return true;
    }

    if (initial_settings.startup.auto_launch_processes !=
        current_settings.startup.auto_launch_processes)
    {
        return true;
    }

    if (initial_settings.nodes.length() !=
        current_settings.nodes.length())
    {
        return true;
    }

    for (::CORBA::ULong i = 0; i != initial_settings.nodes.length(); i++)
    {
        ICPM_module::NodeDef node_init = initial_settings.nodes[i];

        std::string node_id = node_init.node_id.operator const CORBA::Char *();

        ICPM_module::NodeDef node;
        if (!CPMUtils_ns::CPMUtils::get_node_from_settings(current_settings_, node_id, node))
        {
            return true;
        }

        if (node.enabled != node_init.enabled)
        {
            return true;
        }

        if (node_init.processes.length() != node.processes.length())
        {
            return true;
        }

        for (::CORBA::ULong j = 0; j != node_init.processes.length(); j++)
        {
            ICPM_module::ProcessDef proc_init = node_init.processes[j];

            std::string proc_id = proc_init.process_id.operator const CORBA::Char *();

            ICPM_module::ProcessDef proc;
            if (!CPMUtils_ns::CPMUtils::get_process_from_settings(current_settings, node_id, proc_id, proc))
            {
                return true;
            }

            if (proc.enabled != proc_init.enabled)
            {
                return true;
            }

            std::string env_var_id_init = proc_init.env_var_id.operator const CORBA::Char *();
            std::string env_var_id = proc.env_var_id.operator const CORBA::Char *();
            if (env_var_id != env_var_id_init)
            {
                return true;
            }

            std::string module_name_init = proc_init.module_name.operator const CORBA::Char *();
            std::string module_name = proc.module_name.operator const CORBA::Char *();
            if (module_name != module_name_init)
            {
                return true;
            }

            std::string port_number_init = proc_init.port_number.operator const CORBA::Char *();
            std::string port_number = proc.port_number.operator const CORBA::Char *();

            if (port_number != port_number_init)
            {
                return true;
            }
        }
    }

    return false;
}

bool CPMGFrame::local_settings_changed()
{
    return settings_changed(initial_settings_, current_settings_);
}

bool CPMGFrame::remote_settings_changed(
        ICPM_module::CPMMSettings & new_current_settings,
        std::string & new_current_settings_file)
{
    if (CORBA::is_nil(cpmm_obj_))
    {
        return false;
    }

    try
    {
        ICPM_module::CPMMSettings_var current_initial_settings_var;
        ICPM_module::CPMMSettings_var current_current_settings_var;
        ::CORBA::String_var current_settings_file;
        cpmm_obj_->get_settings(current_initial_settings_var, current_current_settings_var, current_settings_file);

        new_current_settings = current_current_settings_var;
        new_current_settings_file = current_settings_file;

        if (settings_changed(new_current_settings, current_settings_)
            || new_current_settings_file != current_settings_file_)
        {
            return true;
        }
    }
    catch(...)
    {
        report("CPMM seems to be unreachable (unable to get settings).");
        return false;
    }

    return false;
}

bool CPMGFrame::get_cpmm_started_status(bool & started)
{
    if (CORBA::is_nil(cpmm_obj_))
    {
        return false;
    }

    try
    {
        if (cpmm_obj_->started())
        {
            started = true;
        }
        else
        {
            started = false;
        }
    }
    catch(...)
    {
        report("CPMM seems to be unreachable (unable to get started status).");
        return false;
    }

    return true;
}

void CPMGFrame::on_button_load(wxCommandEvent &)
{
    if (local_settings_changed())
    {
        wxString msg = wxString::Format("There are changes!\n\n"
                                "Do you want to overwrite these changes?");
        int rc = wxMessageBox(
                    msg,
                    "Loading",
                    wxYES_NO | wxICON_WARNING);
        if (rc == wxNO)
        {
            return;
        }
    }

    bool started;
    if (get_cpmm_started_status(started))
    {
        if (started)
        {
            wxMessageBox(
                "To load new settings, CPMM must be stopped",
                "Loading configuration",
                wxOK | wxICON_WARNING);
            return;
        }
    }
    else
    {
        wxMessageBox(
            "Can't load config",
            "Loading configuration",
            wxOK | wxICON_ERROR);
        return;
    }

    if (!load_settings(initial_settings_, current_settings_, current_settings_file_))
    {
        return;
    }

    if (cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_))
    {
        fill_tree(current_settings_);
    }
}

void CPMGFrame::on_button_save(wxCommandEvent &)
{
    save_options(false);

    if (CORBA::is_nil(cpmm_obj_))
    {
        return;
    }

    try
    {
        cpmm_obj_->save_settings_to(current_settings_file_.c_str());
        initial_settings_ = current_settings_;
        set_widgets_status();
    }
    catch(...)
    {
        wxMessageBox("Failed to save.",
                        "Saving",
                        wxOK | wxICON_ERROR);
    }
}

void CPMGFrame::on_button_save_as(wxCommandEvent &)
{
    save_options(false);

    if (CORBA::is_nil(cpmm_obj_))
    {
        return;
    }

    std::string path;
    if (!CPMUtils_ns::CPMUtils::get_cpmm_settings_path(path))
    {
        wxMessageBox(
            "Can't get CPMM settings path",
            "Saving",
            wxOK | wxICON_ERROR);
        return;
    }

    wxFileDialog dlg(this);
    dlg.SetDirectory(path.c_str());

    if (dlg.ShowModal() == wxID_OK)
    {
        std::string file = dlg.GetPath().c_str();

        bool save(true);
        if(CPMUtils_ns::CPMUtils::file_exists(file))
        {
            wxString msg = wxString::Format("%s already exists.\n\n"
                                            "Do you want to overwrite this file?", file.c_str());
            int rc = wxMessageBox(
                        msg,
                        "Saving",
                        wxYES_NO | wxICON_WARNING);
            if (rc == wxNO)
            {
                save = false;
            }
        }

        if (save)
        {
            try
            {
                cpmm_obj_->save_settings_to(file.c_str());
            }
            catch(...)
            {
                wxMessageBox("Failed to save.",
                                "Saving",
                                wxOK | wxICON_ERROR);
            }

            // Set window title with the name of the config file
            set_title(file);
        }
    }
}

void CPMGFrame::on_button_set_as_default(wxCommandEvent &)
{
    if (CORBA::is_nil(cpmm_obj_))
    {
        return;
    }

    try
    {
        if (!cpmm_obj_->set_as_default())
        {
            wxMessageBox("Failed to set as default.",
                            "Default",
                            wxOK | wxICON_ERROR);
        }

        set_title(current_settings_file_);
    }
    catch(...)
    {
        report("CPMM seems to be unreachable (unable to set settings as default).");
        return;
    }
}

void CPMGFrame::on_button_boot_cpm(wxCommandEvent &event)
{
    wxBusyCursor wait_cursor;
    
    bool cpmm = checkbox_console_cpmm->GetValue();
    bool cpmd = checkbox_console_cpmd->GetValue();
    bool overwrite_autostart_to_false = checkbox_overwrite_auto_start_to_false->GetValue();

    if (!CPMUtils_ns::CPMUtils::boot_cpm(true, cpmm, cpmd, overwrite_autostart_to_false))
    {
        wxMessageBox("Can't boot CPM.\n\nSee system log.");
        return;
    }

    bool ok(true);

    ACE_Time_Value begin = ACE_OS::gettimeofday();

    std::string msg;
    while ((ACE_OS::gettimeofday() - begin).get_msec() < 3000)
    {
        msg = "";

        std::list<std::string> list;
        if (!CPMUtils_ns::CPMUtils::get_system_processes_list(list))
        {
            ok = false;
            msg += "Can't verify that CPMM is started.";
        }

        if (std::find(list.begin(), list.end(), CPMUtils_ns::CPMUtils::cpmd_name() + CPMUtils_ns::CPMUtils::proc_extention()) == list.end())
        {
            ok = false;
            msg += " --- CPMD not started after trying to boot CPM. See system log.";
        }
        else
        {
            ok = true;
            msg = "CPMD booted.";
            break;
        }
    }

    report(msg.c_str());

    if (ok)
    {
        ICPM_module::CPMMSettings new_settings; // empty settings
        current_settings_ = new_settings; // refresh current_settings with empty ones.
        fill_tree(current_settings_);
        if (!m_pTimer->IsRunning())
        {
            m_pTimer->Start(500);
        }
    }
}

void CPMGFrame::on_button_shutdown_cpmm(wxCommandEvent &event)
{
    wxBusyCursor wait_cursor;
    
    m_pTimer->Stop();

    if (!CPMUtils_ns::CPMUtils::shutdown_cpmm())
    {
        wxMessageBox("Can't shutdown CPMM.\n\nSee log file or system log.");
        m_pTimer->Start();
    }
    else
    {
        current_settings_ = initial_settings_;
        set_title(current_settings_file_);
        tree_ctrl_nodes->DeleteAllItems();
        cpmm_obj_ = 0;
        report("CPMM shut down.");
    }
}

void CPMGFrame::on_button_shutdown_cpmd(wxCommandEvent &event)
{
    int rc = wxMessageBox(
                "This operation is not supposed to be done.\n"
                "It is available for drastic situations.\n"
                "If you shutdown CPMD, some applications may crash.\n\n"
                "Do you really want to shutdown CPMD (and CPMM) ?",
                "Shutdown",
                wxYES_NO | wxICON_WARNING);
    if (rc == wxYES)
    {
        wxBusyCursor wait_cursor;
    
        m_pTimer->Stop();

        if (!CPMUtils_ns::CPMUtils::shutdown_cpmm())
        {
            wxMessageBox("Can't shutdown CPMM.\n\nSee log file or system log.");
            m_pTimer->Start();
        }
        else
        {
            report("CPMM shut down.");

            tree_ctrl_nodes->DeleteAllItems();
            cpmm_obj_ = 0;

            if (!CPMUtils_ns::CPMUtils::shutdown_cpmd())
            {
                wxMessageBox("Can't shutdown CPMD.\n\nSee log file or system log.");
            }
            else
            {
                report("CPMD shut down.");
            }
        }
    }
}

void CPMGFrame::on_checkbox_cpmg(wxCommandEvent &event)
{
    // Not useful (listctrl is used instead)
    //if (checkbox_cpmg->GetValue())
    //{
    //    console_.show(true);
    //}
    //else
    //{
    //    console_.show(false);
    //}
}

void CPMGFrame::on_sel_changed(wxTreeEvent &event)
{
    wxTreeItemId item = event.GetItem();
    
    // Ne semble pas nécessaire à première vue.
    //wxTreeItemId old_item  = event.GetOldItem();

    if (item.IsOk())
    {
        wxTreeItemId root = tree_ctrl_nodes->GetRootItem();

        // Ne semble pas nécessaire à première vue.
        //if (item == root)
        //{
        //    // Don't refresh uselessly.
        //    if (old_item.IsOk()
        //        && old_item != item)
        //    {
        //        post_refresh();
        //    }

        //    return;
        //}

        wxTreeItemId item_parent = tree_ctrl_nodes->GetItemParent(item);

        if (item_parent.IsOk())
        {
            std::string sel_item_text;

            if (item_parent == root)
            {
                sel_item_text = tree_ctrl_nodes->GetItemText(item).c_str();
            }
            else
            {
                wxTreeItemId item_parent_parent = tree_ctrl_nodes->GetItemParent(item_parent);
                if (item_parent_parent.IsOk())
                {
                    if (item_parent_parent == root)
                    {
                        sel_item_text = tree_ctrl_nodes->GetItemText(item_parent).c_str();
                    }
                    else
                    {
                        sel_item_text = tree_ctrl_nodes->GetItemText(item_parent_parent).c_str();
                    }
                }
            }

            fill_processes_list(sel_item_text);
        }
    }
}

void CPMGFrame::on_tree_key_down(wxTreeEvent &event)
{
    int key_code = event.GetKeyCode();

    if (key_code == WXK_F2)
    {
        wxArrayTreeItemIds items;
        tree_ctrl_nodes->GetSelections(items);

        if (items.GetCount() != 0)
        {
            enum_item_type type = get_selection_type();
            if (type == ROOT
                || type == NODE)
            {
                // Edit labels for root and nodes only.
                wxArrayTreeItemIds items;
                tree_ctrl_nodes->GetSelections(items);
                wxTreeItemId item = items[0];

                tree_ctrl_nodes->EditLabel(item);
            }
        }
    }
}

void CPMGFrame::on_tree_end_label_edit(wxTreeEvent &event)
{
    std::string new_label = event.GetLabel();

    if (new_label.empty())
    {
        event.Veto();
        return;
    }

    enum_item_type type = get_selection_type();
    switch(type)
    {
        case ROOT:
        {
            cpmm_update_settings_id(new_label);
        }
        break;

        case NODE:
        {
            wxArrayTreeItemIds items;
            tree_ctrl_nodes->GetSelections(items);
            std::string old_node_id = tree_ctrl_nodes->GetItemText(items[0]);

            if (!new_label.empty()
                && old_node_id != new_label)
            {
                cpmm_update_node_id(old_node_id, new_label, event);
            }

            for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
            {
                //std::string settings_node_id = current_settings_.nodes[i].node_id.operator const CORBA::Char *();
                if (old_node_id == old_node_id/*settings_node_id*/)
                {
                    std::string env_var_id = current_settings_.nodes[i].env_var.operator const CORBA::Char *();
                    if (env_var_id != "")
                    {
                        wxString msg = wxString::Format("This node (%s) is defined as environment variable: %s. "
                                                        "You should change the value of environment variable too. "
                                                        "Otherwise, you can click on 'No' to save the node address as %s.\n\n"
                                                        "Do you want to keep defining this node as environment variable (and change the value of the environment variable) ?",
                                                        old_node_id,
                                                        env_var_id, 
                                                        new_label);
                        int rc = wxMessageBox(msg, "Change of environment variable value", wxYES_NO);
                        if (rc == wxNO)
                        {
                            current_settings_.nodes[i].node_id = new_label.c_str();
                            current_settings_.nodes[i].env_var = "";

                            if (cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_))
                            {
                                //fill_tree(current_settings_, true);
                            }
                        }
                        break;
                    }
                }
            }

            event.Veto(); // Cancel label edit because tree is refreshed.
        }
        break;

        default:
            event.Veto();
    }

    hide_objects();
    button_show_objects->SetLabel(show_objects_string.c_str());
    show_objects_ = true;
}

void CPMGFrame::on_list_msg_click(wxCommandEvent &)
{
    wxMessageBox("Haha");
}

void CPMGFrame::on_cell_changed_grid_procs(wxGridEvent &event)
{
    enum_item_type type = get_selection_type();
    int row = event.GetRow();

    wxString old_value = event.GetString();
    int changed_col = event.GetCol();

    enum order {
        col_process_id,
        col_env_var_id,
        col_module_name,
        col_port_number
    };

    wxArrayTreeItemIds items;
    tree_ctrl_nodes->GetSelections(items);

    std::string selected_node_id;

    switch(type)
    {
        case ROOT:
            // Processes don't appear when root is selected
            break;

        case NODE:
            selected_node_id = tree_ctrl_nodes->GetItemText(items[0]);
            break;

        case PROCESS:
            {
                wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(items[0]);
                selected_node_id = tree_ctrl_nodes->GetItemText(parent);
            }
            break;

        case OBJECT:
            {
                wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(items[0]);
                wxTreeItemId parent_parent = tree_ctrl_nodes->GetItemParent(parent);
                selected_node_id = tree_ctrl_nodes->GetItemText(parent_parent);
            }
            break;
    }

    ICPM_module::NodeDef node;
    if (CPMUtils_ns::CPMUtils::get_node_from_settings(current_settings_, selected_node_id, node))
    {
        std::string grid_process_id = grid_processes->GetCellValue(row, col_process_id);
        std::string grid_env_var_id = grid_processes->GetCellValue(row, col_env_var_id);
        std::string grid_module_name = grid_processes->GetCellValue(row, col_module_name);
        std::string grid_port_number = grid_processes->GetCellValue(row, col_port_number);

        for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
        {
            ::CORBA::ULong j(0);

            bool changed(false);
            ICPM_module::NodeDef node = current_settings_.nodes[i];
            std::string node_id = node.node_id;
            ICPM_module::ProcessDef settings_proc;
            if (node_id == selected_node_id)
            {
                for (j = 0; j != node.processes.length(); j++)
                {
                    settings_proc = node.processes[j];

                    std::string settings_proc_id = settings_proc.process_id.operator const CORBA::Char *();
                    std::string settings_env_var_id = settings_proc.env_var_id.operator const CORBA::Char *();
                    std::string settings_module_name = settings_proc.module_name.operator const CORBA::Char *();
                    std::string settings_port_number = settings_proc.port_number.operator const CORBA::Char *();

                    if (changed_col == col_process_id)
                    {
                        if (old_value == settings_proc_id)
                        {
                            changed = true;
                            break;
                        }
                    }
                    else
                    {
                        if (grid_process_id == settings_proc_id)
                        {
                            changed = true;
                            break;
                        }
                    }
                }
            }

            if (changed)
            {
                if (ask_for_stopping(PROCESS))
                {
                    wxBusyCursor wait_cursor;

                    current_settings_.nodes[i].processes[j].process_id = grid_process_id.c_str();
                    current_settings_.nodes[i].processes[j].env_var_id = grid_env_var_id.c_str();
                    current_settings_.nodes[i].processes[j].module_name = grid_module_name.c_str();
                    current_settings_.nodes[i].processes[j].port_number = grid_port_number.c_str();

                    ICPM_module::ProcessSeq proc_seq;
                    proc_seq.length(1);
                    proc_seq[0] = settings_proc;
                    stop(proc_seq);

                    cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_);

                    post_refresh();
                }
                else
                {
                    event.Veto();
                }

                break;
            }
            else
            {
                event.Veto();
            }
        }
    }
    else
    {
        wxString msg = wxString::Format("Can't get node %s from settings.", selected_node_id.c_str());
        wxMessageBox(
            msg,
            "Process update",
            wxOK | wxICON_ERROR);
        event.Veto();
    }
}

void CPMGFrame::on_button_clear_msg(wxCommandEvent &)
{
    list_box_msg->Clear();
}

void CPMGFrame::on_button_show_objects(wxCommandEvent &)
{
    show_objects();
}

void CPMGFrame::on_refresh(wxCommandEvent &)
{
    fill_tree(current_settings_);
}

void CPMGFrame::on_close(wxCloseEvent& event)
{
    quit(event);
}

void CPMGFrame::OnTimerTimeout(wxTimerEvent& event)
{
    wxTreeItemId root = tree_ctrl_nodes->GetRootItem();

    try
    {
        if (!cpmd_connection_test_done_once_
            && !test_cpmd_connection())
        {
            report("CPMD not booted.");
            cpmd_connection_test_done_once_ = true;
            return;
        }

        if (CORBA::is_nil(cpmm_obj_))
        {
            // When CPMG is started and button "Boot CPM" is not called yet and
            // another booter start CPM, we are interested having the status
            // up to date.

            if (!get_ref_on_cpmm())
            {
                return;
            }

            try
            {
                ::CORBA::String_var settings_file;
                ::ICPM_module::CPMMSettings_var init_settings;
                ::ICPM_module::CPMMSettings_var curr_settings;
                cpmm_obj_->get_settings(curr_settings, init_settings, settings_file);
                
                current_settings_ = curr_settings;
                initial_settings_ = init_settings;
                current_settings_file_ = settings_file;
            }
            catch(...)
            {
                report("CPMM seems to be unreachable (unable to get current settings).");
                return;
            }

            fill_tree(current_settings_, true);
            set_title(current_settings_file_);

            root = tree_ctrl_nodes->GetRootItem();
        }

        ICPM_module::CPMMSettings new_current_settings;
        std::string new_current_settings_file;
        if (remote_settings_changed(new_current_settings, new_current_settings_file))
        {
            current_settings_ = new_current_settings;
            current_settings_file_ = new_current_settings_file;
            fill_tree(current_settings_);
            set_title(current_settings_file_);
            return;
        }

        static ICPM_module::UnavailableElementIDSeq last_nodes;
        static ICPM_module::UnavailableElementIDSeq last_processes;

        ICPM_module::UnavailableElementIDSeq nodes(last_nodes);
        ICPM_module::UnavailableElementIDSeq processes(last_processes);
        if (get_unavailable(nodes, processes))
        {
            last_nodes = nodes;
            last_processes = processes;
        }

        //// Nodes
        wxTreeItemIdValue cookie;
        wxTreeItemId node_item = tree_ctrl_nodes->GetFirstChild(root, cookie);
        while (node_item.IsOk())
        {
            std::string node_id = tree_ctrl_nodes->GetItemText(node_item);

            ICPM_module::NodeDef node;
            if (CPMUtils_ns::CPMUtils::get_node_from_settings(current_settings_, node_id, node))
            {
                if (!node.enabled)
                {
                    wxColour colour = tree_ctrl_nodes->GetItemBackgroundColour(node_item);
                    if (colour != color_disabled)
                    {
                        tree_ctrl_nodes->SetItemBackgroundColour(node_item, color_disabled);
                    }
                }
                else
                {
                    if (node_unavailable(node_id, nodes))
                    {
                        wxColour colour = tree_ctrl_nodes->GetItemBackgroundColour(node_item);
                        if (colour != color_unavailable)
                        {
                            tree_ctrl_nodes->SetItemBackgroundColour(node_item, color_unavailable);
                        }
                    }
                    else
                    {
                        wxColour colour = tree_ctrl_nodes->GetItemBackgroundColour(node_item);
                        if (colour != color_available)
                        {
                            tree_ctrl_nodes->SetItemBackgroundColour(node_item, color_available);
                        }
                    }
                }
            }

            node_item = tree_ctrl_nodes->GetNextChild(root, cookie);
        }

        // Processes
        wxTreeItemIdValue cookie_node;
        node_item = tree_ctrl_nodes->GetFirstChild(root, cookie_node);
        while (node_item.IsOk())
        {
            std::string node_id = tree_ctrl_nodes->GetItemText(node_item);

            wxTreeItemIdValue cookie_proc;
            wxTreeItemId proc_item = tree_ctrl_nodes->GetFirstChild(node_item, cookie_proc);
            while (proc_item.IsOk())
            {
                std::string proc_id = tree_ctrl_nodes->GetItemText(proc_item);
                size_t pos = proc_id.find('(');
                proc_id = proc_id.substr(0, pos - 1);

                ICPM_module::ProcessDef proc;
                if (CPMUtils_ns::CPMUtils::get_process_from_settings(current_settings_, node_id, proc_id, proc))
                {
                    std::string node_id = proc.node_id.operator const CORBA::Char *();

                    ICPM_module::NodeDef node;
                    if (CPMUtils_ns::CPMUtils::get_node_from_settings(current_settings_, node_id, node))
                    {
                        if (!proc.enabled
                            || !node.enabled)
                        {
                            wxColour colour = tree_ctrl_nodes->GetItemBackgroundColour(proc_item);
                            if (colour != color_disabled)
                            {
                                tree_ctrl_nodes->SetItemBackgroundColour(proc_item, color_disabled);
                            }
                        }
                        else
                        {
                            if (process_unavailable(node_id, proc_id, processes))
                            {
                                wxColour colour = tree_ctrl_nodes->GetItemBackgroundColour(proc_item);
                                if (colour != color_unavailable)
                                {
                                    tree_ctrl_nodes->SetItemBackgroundColour(proc_item, color_unavailable);
                                }
                            }
                            else
                            {
                                wxColour colour = tree_ctrl_nodes->GetItemBackgroundColour(proc_item);
                                if (colour != color_available)
                                {
                                    tree_ctrl_nodes->SetItemBackgroundColour(proc_item, color_available);
                                }
                            }
                        }
                    }
                }

                proc_item = tree_ctrl_nodes->GetNextChild(node_item, cookie_proc);
            }

            node_item = tree_ctrl_nodes->GetNextChild(root, cookie_node);
        }
    }
    catch(...)
    {
        wxLogDebug("Monitoring failure.");
    }
}

void CPMGFrame::on_tree_item_right_click(wxTreeEvent &event)
{
    wxTreeItemId item = event.GetItem();

    if (item.IsOk())
    {
        wxString sel_item_text = tree_ctrl_nodes->GetItemText(item).c_str();

        wxTreeItemId root = tree_ctrl_nodes->GetRootItem();

        enum_item_type type;

        wxMenu menu;
        if (item == root)
        {
            tree_ctrl_nodes->UnselectAll();
            tree_ctrl_nodes->SelectItem(item);

            type = ROOT;
        }
        else
        {
            wxTreeItemId item_parent = tree_ctrl_nodes->GetItemParent(item);

            if (item_parent == root)
            {
                // Node

                // Keep track of selected items
                wxArrayTreeItemIds items;
                tree_ctrl_nodes->GetSelections(items);

                // Unselect all items
                tree_ctrl_nodes->UnselectAll();

                // Select relevant items only (nodes)
                for (unsigned int i = 0; i != items.GetCount(); i++)
                {
                    wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(items[i]);

                    if (parent.IsOk()
                        && parent == root)
                    {
                        tree_ctrl_nodes->SelectItem(items[i]);
                    }
                }

                type = NODE;
            }
            else
            {
                wxTreeItemId item_parent_parent = tree_ctrl_nodes->GetItemParent(item_parent);

                if (item_parent_parent == root)
                {
                    // Process

                    // Keep track of selected items
                    wxArrayTreeItemIds items;
                    tree_ctrl_nodes->GetSelections(items);

                    // Unselect all items
                    tree_ctrl_nodes->UnselectAll();

                    // Select relevant items only (processes)
                    for (unsigned int i = 0; i != items.GetCount(); i++)
                    {
                        wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(items[i]);
                        wxTreeItemId parent_parent = tree_ctrl_nodes->GetItemParent(parent);
                        if (parent_parent == root)
                        {
                            tree_ctrl_nodes->SelectItem(items[i]);
                        }
                    }

                    type = PROCESS;
                }
                else
                {
                    // Object

                    // Keep track of selected items
                    wxArrayTreeItemIds items;
                    tree_ctrl_nodes->GetSelections(items);

                    // Unselect all items
                    tree_ctrl_nodes->UnselectAll();

                    // Select relevant items only (objects)
                    for (unsigned int i = 0; i != items.GetCount(); i++)
                    {
                        wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(items[i]);
                        if (parent.IsOk())
                        {
                            wxTreeItemId parent_parent = tree_ctrl_nodes->GetItemParent(parent);
                            if (parent_parent.IsOk())
                            {
                                wxTreeItemId parent_parent_parent = tree_ctrl_nodes->GetItemParent(parent_parent);
                                if (parent_parent_parent.IsOk())
                                {
                                    if (parent_parent_parent == root)
                                    {
                                        tree_ctrl_nodes->SelectItem(items[i]);
                                    }
                                }
                            }
                        }
                    }

                    type = OBJECT;
                }
            }
        }

        bool started(false);
        if (get_cpmm_started_status(started))
        {
            if (type == ROOT
                || type == NODE
                || type == PROCESS)
            {
                menu.Append(POPUP_START, "Start");
                menu.Append(POPUP_STOP, "Stop");
                menu.Append(POPUP_SHOW_CONSOLE, "Show console");
                menu.Append(POPUP_HIDE_CONSOLE, "Hide console");
            }

            if (type == ROOT)
            {
                menu.Append(POPUP_NEW_NODE, "New node");
            }

            if (type == NODE
                || type == PROCESS)
            {
                menu.Append(POPUP_ENABLE, "Enable");
                menu.Append(POPUP_DISABLE, "Disable");
            }

            if (type == NODE)
            {
                menu.Append(POPUP_NEW_PROCESS, "New process");
                menu.Append(POPUP_PIDS, "Pids");
            }

            if (type == NODE
                || type == PROCESS)
            {
                menu.Append(POPUP_REMOVE, "Remove");
            }

            if (type == OBJECT)
            {
                menu.Append(POPUP_GET_VERSION, "Get version");
            }

            wxPoint point = event.GetPoint();
            PopupMenu(&menu, point);
        }
    }
}

void CPMGFrame::on_new_node(wxCommandEvent &)
{
    ICPM_module::NodeDef new_node;

    NodeDlg dlg(this,
                    -1,
                    "",
                    wxDefaultPosition,
                    wxDefaultSize,
                    wxDEFAULT_FRAME_STYLE|wxTAB_TRAVERSAL|wxRESIZE_BORDER);

    if (dlg.ShowModal() == wxID_OK)
    {
        std::string node_id = dlg.node_id().ToStdString();
        if (!cpmm_add_node(node_id))
        {
            wxString msg = wxString::Format("Can't add node %s", node_id.c_str());
            wxMessageBox(
                msg,
                "New node",
                wxOK | wxICON_ERROR);
        }
        else
        {
            fill_tree(current_settings_, true);
        }
    }
}

void CPMGFrame::on_new_process(wxCommandEvent &)
{
    ICPM_module::ProcessDef new_proc;

    ProcessDlg dlg(this,
                    -1,
                    "",
                    wxDefaultPosition,
                    wxDefaultSize,
                    wxDEFAULT_FRAME_STYLE|wxTAB_TRAVERSAL|wxRESIZE_BORDER);

    if (dlg.ShowModal() == wxID_OK)
    {
        new_proc.process_id = dlg.process_id().c_str();
        new_proc.env_var_id = dlg.env_var_id().c_str();
        new_proc.module_name = dlg.module_name().c_str();
        new_proc.port_number = dlg.port().c_str();
        new_proc.enabled = dlg.enabled() ? 1 : 0;

        wxArrayTreeItemIds items;
        tree_ctrl_nodes->GetSelections(items);

        for (unsigned int i = 0; i != items.GetCount(); i++)
        {
            wxTreeItemId item = items[i];

            std::string node_id = tree_ctrl_nodes->GetItemText(item);

            new_proc.node_id = node_id.c_str();

            ICPM_module::NodeDef updated_node;
            if (!CPMUtils_ns::CPMUtils::get_node_from_settings(current_settings_, node_id, updated_node))
            {
                report("Can't get node from settings.");
                return;
            }

            ::CORBA::ULong proc_count = updated_node.processes.length();
            updated_node.processes.length(proc_count + 1);
            updated_node.processes[proc_count] = new_proc;

            for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
            {
                if (current_settings_.nodes[i].node_id == node_id)
                {
                    current_settings_.nodes[i] = updated_node;
                }
            }
        }

        if (cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_))
        {
            fill_tree(current_settings_, true);
        }
    }
}

bool CPMGFrame::init()
{
    // Check if the node is the same as CPMM_NODE.
    std::string node;
    CPMUtils_ns::CPMUtils::get_cpmm_node(node);
    if (node != CPMUtils_ns::CPMUtils::get_local_addr())
    {
        wxString msg = wxString::Format(
            "CPMM_NODE is defined as %s while the current node is %s.\n"
            "CPMM_NODE must be defined as %s",
            CPMUtils_ns::CPMUtils::get_local_addr().c_str(),
            node.c_str(),
            CPMUtils_ns::CPMUtils::get_local_addr().c_str());
        wxMessageBox(
            msg,
            "CPMG startup",
            wxOK | wxICON_ERROR);
        return false;
    }

    if (test_cpmd_connection()
        && get_ref_on_cpmm())
    {
        // If CPMM is already started, get its settings and fill tree.
        try
        {
            ::CORBA::String_var settings_file;
            ::ICPM_module::CPMMSettings_var init_settings;
            ::ICPM_module::CPMMSettings_var curr_settings;
            cpmm_obj_->get_settings(init_settings, curr_settings, settings_file);

            initial_settings_ = init_settings;
            current_settings_ = curr_settings;
            current_settings_file_ = settings_file;
        }
        catch(...)
        {
            wxMessageBox(
                "Can't get current settings from CPMM.\n",
                "CPMG startup",
                wxOK | wxICON_ERROR);
            return false;
        }

        fill_tree(current_settings_);

        std::string default_settings_file;
        if (CPMUtils_ns::CPMUtils::get_default_cpmm_settings_file(default_settings_file))
        {
            set_title(current_settings_file_);
        }
    }

    m_pTimer->Start(500);

    return true;
}

bool CPMGFrame::get_ref_on_cpmm()
{
    std::string port;
    if (!CPMUtils_ns::CPMUtils::get_cpmm_port(port))
    {
        wxMessageBox(
            "Can't get CPMM ip port.\n\n"
            "Is CPMM_PORT defined?",
            "CPMG",
            wxOK | wxICON_ERROR);
        return false;
    }

    std::string cpmm_node;
    if (!CPMUtils_ns::CPMUtils::get_cpmm_node(cpmm_node))
    {
        report("failed to get cpmm node environment variable CPMM_NODE");
        return false;
    }

    std::string location = std::string("corbaloc:iiop:") + cpmm_node + ":" + port + "/" + "CPMMObj";

    if (!EnvVarExpand_ns::EnvVarExpand::expand_env_variables(location, location))
    {
        report("failed to expand environment variable '%s'", location.c_str());
        return false;
    }

    int prev_connection_timeout;
    CPMTAOLAYER->get_connection_timeout_orb(prev_connection_timeout);

    // If CPMM_NODE is the current local address, we set timeouts smaller
    // local access to cpmm is fast, else it means cpmm is not there.
    if (CPMUtils_ns::CPMUtils::get_local_addr() == cpmm_node)
    {
        CPMTAOLAYER->set_connection_timeout_orb(100);
    }

    CPMTAOLayer::GetRefStatus status;
    cpmm_obj_ = CPMTAOLAYER->get_ref_from_iortable<::ICPM_module::ICPMM>(location.c_str(), status, 1, 100, true);

    if (CPMUtils_ns::CPMUtils::get_local_addr() == cpmm_node)
    {
        CPMTAOLAYER->set_connection_timeout_orb(prev_connection_timeout);
    }

    if(!cpmm_obj_)
    {
        return false;
    }

    return true;
}

enum_item_type CPMGFrame::get_selection_type()
{
    wxTreeItemId root = tree_ctrl_nodes->GetRootItem();

    // Selected items.
    wxArrayTreeItemIds items;
    tree_ctrl_nodes->GetSelections(items);

    wxTreeItemId one_item = items[0];
    if (one_item == root)
    {
        return ROOT;
    }
    else
    {
        wxTreeItemId parent = tree_ctrl_nodes->GetItemParent(one_item);

        if (parent == root)
        {
            return NODE;
        }
        else
        {
            wxTreeItemId parent_of_parent = tree_ctrl_nodes->GetItemParent(parent);

            if (parent_of_parent == root)
            {
                return PROCESS;
            }
            else
            {
                return OBJECT;
            }
        }
    }
}

void CPMGFrame::on_start(wxCommandEvent &event)
{
    wxBusyCursor wait_cursor;

    start(event);

    fill_tree(current_settings_, true);
}

void CPMGFrame::on_stop(wxCommandEvent &)
{
    wxBusyCursor wait_cursor;

    ICPM_module::ProcessSeq proc_seq = get_selected_procs();
    stop(proc_seq);

    fill_tree(current_settings_, true);
}

void CPMGFrame::on_show_console(wxCommandEvent &)
{
    wxBusyCursor wait_cursor;

    ICPM_module::ProcessSeq proc_seq = get_selected_procs();
    show_console(proc_seq, 1);
}

void CPMGFrame::on_hide_console(wxCommandEvent &)
{
    wxBusyCursor wait_cursor;

    ICPM_module::ProcessSeq proc_seq = get_selected_procs();
    show_console(proc_seq, 0);
}

void CPMGFrame::on_enable(wxCommandEvent &)
{
    wxBusyCursor wait_cursor;
    enable(true);
    fill_tree(current_settings_, true);
}

void CPMGFrame::on_disable(wxCommandEvent &)
{
    enum_item_type item_type = get_selection_type();

    if (ask_for_stopping(item_type))
    {
        wxBusyCursor wait_cursor;
        ICPM_module::ProcessSeq proc_seq = get_selected_procs();
        stop(proc_seq);
        enable(false);
        fill_tree(current_settings_, true);
    }
}

void CPMGFrame::on_remove(wxCommandEvent &)
{
    enum_item_type type = get_selection_type();

    if (ask_for_stopping(type))
    {
        wxBusyCursor wait_cursor;

        ICPM_module::ProcessSeq proc_seq = get_selected_procs();
        stop(proc_seq);

        ICPM_module::CPMMSettings new_settings;

        new_settings.settings_id = current_settings_.settings_id;
        new_settings.startup = current_settings_.startup;

        wxArrayTreeItemIds items;
        tree_ctrl_nodes->GetSelections(items);

        for (unsigned int i = 0; i != items.GetCount(); i++)
        {
            if (type == NODE)
            {
                std::string node_id_tree = tree_ctrl_nodes->GetItemText(items[i]);

                new_settings.nodes.length(current_settings_.nodes.length() - 1);
                ::CORBA::ULong n(0);

                for (::CORBA::ULong j = 0; j != current_settings_.nodes.length(); j++)
                {
                    ICPM_module::NodeDef node = current_settings_.nodes[j];
                    std::string node_id = node.node_id.operator const CORBA::Char *();

                    if (node_id != node_id_tree)
                    {
                        new_settings.nodes[n++] = node;
                    }
                }
            }

            if (type == PROCESS)
            {
                std::string proc_id_tree = tree_ctrl_nodes->GetItemText(items[i]);

                wxTreeItemId item_parent = tree_ctrl_nodes->GetItemParent(items[i]);
                std::string node_id_tree = tree_ctrl_nodes->GetItemText(item_parent);

                new_settings.nodes.length(current_settings_.nodes.length());

                for (::CORBA::ULong j = 0; j != current_settings_.nodes.length(); j++)
                {
                    ICPM_module::NodeDef node = current_settings_.nodes[j];
                    std::string node_id = node.node_id.operator const CORBA::Char *();

                    if (node_id != node_id_tree)
                    {
                        new_settings.nodes[j] = node;
                    }
                    else
                    {
                        ICPM_module::NodeDef updated_node;
                        updated_node.enabled = node.enabled;
                        updated_node.node_id = node.node_id;

                        updated_node.processes.length(node.processes.length() - 1);
                        ::CORBA::ULong n(0);

                        for (::CORBA::ULong k = 0; k != node.processes.length(); k++)
                        {
                            ICPM_module::ProcessDef proc = node.processes[k];
                            std::string proc_id = proc.process_id.operator const CORBA::Char *();

                            size_t pos = proc_id_tree.find("(");
                            if (pos != std::string::npos)
                            {
                                proc_id_tree = proc_id_tree.substr(0, pos - 1);
                            }

                            if (proc_id != proc_id_tree)
                            {
                                updated_node.processes[n++] = proc;
                            }
                        }

                        new_settings.nodes[j] = updated_node;
                    }
                }
            }
        }

        current_settings_ = new_settings;
        if (cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_))
        {
            fill_tree(current_settings_, true);
        }
    }
}

void CPMGFrame::on_pids(wxCommandEvent &)
{
    wxBusyCursor wait_cursor;

    wxArrayTreeItemIds items;
    tree_ctrl_nodes->GetSelections(items);

    std::map<std::string, long> map_proc_pid;

    ICPM_module::UnavailableElementIDSeq unavail_nodes;
    ICPM_module::UnavailableElementIDSeq unavail_processes;
    if (!get_unavailable(unavail_nodes, unavail_processes))
    {
        report("Failed to get unvailable nodes/processes.");
        return;
    }

    for (unsigned int i = 0; i != items.GetCount(); i++)
    {
        std::string node_id = tree_ctrl_nodes->GetItemText(items[i]);

        for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
        {
            if (current_settings_.nodes[i].enabled)
            {
                if (current_settings_.nodes[i].node_id == node_id)
                {
                    if (node_unavailable(node_id, unavail_nodes))
                    {
                        continue;
                    }

                    for (::CORBA::ULong j = 0; j !=  current_settings_.nodes[i].processes.length(); j++)
                    {
                        if (current_settings_.nodes[i].processes[j].enabled)
                        {
                            std::string process_name = current_settings_.nodes[i].processes[j].process_id.operator const CORBA::Char *();
                            std::string port = current_settings_.nodes[i].processes[j].port_number.operator const CORBA::Char *();

                            if (process_unavailable(node_id, process_name, unavail_processes))
                            {
                                continue;
                            }

                            std::string corbaloc = std::string("corbaloc:iiop:") + node_id + ":" + port + "/" + process_name;

                            if (!EnvVarExpand_ns::EnvVarExpand::expand_env_variables(corbaloc, corbaloc))
                            {
                                report("failed to expand environment variable '%s'", corbaloc.c_str());
                                return;
                            }

                            if (CPMUtils_ns::CPMUtils::ping(node_id))
                            {
                                CPMTAOLayer::GetRefStatus status;
                                ::ICPM_module::ICPMProcess_var cpmo = CPMTAOLAYER->get_ref_from_iortable<::ICPM_module::ICPMProcess>(corbaloc.c_str(), status);
                                if (cpmo)
                                {
                                    try
                                    {
                                        ::CORBA::ULong pid = cpmo->getpid();
                                        map_proc_pid[node_id + " - " + process_name] = pid;
                                    }
                                    catch(...)
                                    {
                                        report("Unable to get object list from %s.", corbaloc.c_str());
                                    }
                                }
                                else
                                {
                                    report("Can't get reference on %s.", corbaloc.c_str());
                                }
                            }
                            else
                            {
                                report("Can't access %s when getting references on objects", node_id.c_str());
                            }
                        }
                    }
                }
            }
        }
    }

    std::stringstream output;
    std::map<std::string, long>::iterator it_proc_pid;
    for (it_proc_pid = map_proc_pid.begin();
            it_proc_pid != map_proc_pid.end();
            it_proc_pid++)
    {
        output << it_proc_pid->first << " = " << it_proc_pid->second << std::endl;
    }

    if (output.str().empty())
    {
        output << "No process id available";
    }

    wxMessageBox(output.str(),
                "Pids",
                wxOK | wxICON_INFORMATION);
}

void CPMGFrame::on_get_version(wxCommandEvent &)
{
    std::map<std::string, std::string> objects_versions;

    std::map<std::string, std::list<std::string> > objects_ids = get_selected_objects();
    std::map<std::string, std::list<std::string> >::iterator it_node;
    for (it_node = objects_ids.begin(); it_node != objects_ids.end(); it_node++)
    {
        std::string node_id = it_node->first;

        std::list<std::string>::iterator it_obj;
        for (it_obj = it_node->second.begin();
                it_obj != it_node->second.end();
                it_obj++)
        {
            std::string obj_key = *it_obj;

            size_t pos = obj_key.find(":");
            if (pos == std::string::npos)
            {
                objects_versions[obj_key] = std::string("?.?.?  (bad object key: ") + obj_key + ")";
                continue;
            }

            std::string proc_id = obj_key.substr(0, pos);
            std::string obj_id = obj_key.substr(pos + 1);

            ICPM_module::ProcessDef proc;
            if (!CPMUtils_ns::CPMUtils::get_process_from_settings(current_settings_, node_id, proc_id, proc))
            {
                objects_versions[obj_key] = std::string("?.?.?  (can't get settings with node: ") + node_id + ", process: " + proc_id + ")";
                continue;
            }

            std::string port_number = proc.port_number.operator const CORBA::Char *();
            std::string location = std::string("corbaloc:iiop:") + node_id + ":" + port_number + "/" + obj_id;

            if (!EnvVarExpand_ns::EnvVarExpand::expand_env_variables(location, location))
            {
                report("failed to expand environment variable '%s'", location.c_str());
                continue;
            }

            CPMTAOLayer::GetRefStatus status;
            ::ICPM_module::ICPMObject_var object = CPMTAOLAYER->get_ref_from_iortable<::ICPM_module::ICPMObject>(location.c_str(), status);
            if(!object)
            {
                objects_versions[obj_key] = std::string("?.?.?  (can't get reference on ") + location + ")";
                continue;
            }

            try
            {
                ::CORBA::Long major;
                ::CORBA::Long minor;
                ::CORBA::Long patch;
                object->get_version(major, minor , patch);
                wxString version = wxString::Format("%d.%d.%d", major, minor , patch);
                objects_versions[obj_key] = version.ToStdString();
            }
            catch(...)
            {
                objects_versions[obj_key] = std::string("?.?.?  (can't get version from ") + location + ")";
                continue;
            }
        }
    }

    std::string output;
    std::map<std::string, std::string>::iterator it_objs_ver;
    for (it_objs_ver = objects_versions.begin();
            it_objs_ver != objects_versions.end();
            it_objs_ver++)
    {
        output += it_objs_ver->first + " = " + it_objs_ver->second + "\n";
    }

    wxMessageBox(output.c_str(),
                "Versions",
                wxOK | wxICON_INFORMATION);
}

void CPMGFrame::report(
            const char * format,
            ...)
{
    va_list args;
    va_start(args, format);
    vreport(format, args);
    va_end(args);
}

void CPMGFrame::vreport(
            const char * format,
            va_list args)
{
    int len;
    char * buffer;

    len = _vscprintf( format, args ) // _vscprintf doesn't count
        + 1; // terminating '\0'

    buffer = (char*)malloc( len * sizeof(char) );

    vsprintf( buffer, format, args );
    puts( buffer );

    std::stringstream ss;

    ACE_Date_Time dt;
    ss << std::setfill('0') << std::setw(4) << dt.year();
    ss << "-";
    ss << std::setfill('0') << std::setw(2) << dt.month(),
    ss << "-";
    ss << std::setfill('0') << std::setw(2) << dt.day(), 
    ss << " ";
    ss << std::setfill('0') << std::setw(2) << dt.hour(),
    ss << ":";
    ss << std::setfill('0') << std::setw(2) << dt.minute(),
    ss << ":";
    ss << std::setfill('0') << std::setw(2) << dt.second(),
    ss << ".";
    ss << std::setfill('0') << std::setw(3) << dt.microsec() / 1000;
    ss << " - ";
    ss << buffer;

    list_box_msg->Append(ss.str().c_str());

    int c = list_box_msg->GetCount();

    list_box_msg->SetFirstItem(list_box_msg->GetCount() - 1); 

    free( buffer );
}

bool CPMGFrame::ask_for_stopping(enum_item_type item_type)
{
    wxString msg;

    switch(item_type)
    {
    case ROOT:
        msg = "Unexpected operation.";
        break;
    case NODE:
        msg = "Disabling/renaming node(s) will stop processes (if started).\n\n"
                "Do you really want to disable/rename node(s)?";
        break;
    case PROCESS:
        msg = "Disabling/updating processes will stop them (if started).\n\n"
                "Do you really want to disable/update processes?";
        break;
    case OBJECT:
        msg = "Unexpected operation.";
        break;
    };

    int rc = wxMessageBox(
                msg,
                "Modification",
                wxYES_NO | wxICON_WARNING);
    if (rc == wxYES)
    {
        return true;
    }

    return false;
}

void CPMGFrame::cpmm_update_settings_id(const std::string & settings_id)
{
    current_settings_.settings_id = settings_id.c_str();
    cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_);
}

bool CPMGFrame::cpmm_update_node_id(
        const std::string & old_node_id,
        const std::string & new_node_id,
        wxTreeEvent &)
{
    if (!ask_for_stopping(NODE))
    {
        return false;
    }

    wxBusyCursor wait_cursor;

    ICPM_module::ProcessSeq proc_seq = get_selected_procs();
    stop(proc_seq);

    for (::CORBA::ULong i = 0; i != current_settings_.nodes.length(); i++)
    {
        if (current_settings_.nodes[i].node_id == old_node_id)
        {
            current_settings_.nodes[i].node_id = new_node_id.c_str();

            for (::CORBA::ULong j = 0; j !=  current_settings_.nodes[i].processes.length(); j++)
            {
                 current_settings_.nodes[i].processes[j].node_id = new_node_id.c_str();
            }
        }
    }

    if (cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_))
    {
        fill_tree(current_settings_, true);
    }

    return true;
}

bool CPMGFrame::cpmm_add_node(const std::string & node_id)
{
    ICPM_module::CPMMSettings new_settings(current_settings_);

    new_settings.nodes.length(current_settings_.nodes.length() + 1);

    ICPM_module::NodeDef new_node;
    new_node.node_id = node_id.c_str();
    new_node.enabled = 0;
    new_settings.nodes[current_settings_.nodes.length()] = new_node;

    current_settings_ = new_settings;
    return cpmm_update_settings(initial_settings_, current_settings_, current_settings_file_);
}

void CPMGFrame::hide_objects()
{
    wxTreeItemId root = tree_ctrl_nodes->GetRootItem();

    wxTreeItemIdValue cookie_node;
    wxTreeItemId node_item = tree_ctrl_nodes->GetFirstChild(root, cookie_node);
    while (node_item.IsOk())
    {
        wxTreeItemIdValue cookie_proc;
        wxTreeItemId proc_item = tree_ctrl_nodes->GetFirstChild(node_item, cookie_proc);
        while (proc_item.IsOk())
        {
            tree_ctrl_nodes->CollapseAllChildren(proc_item);
            proc_item = tree_ctrl_nodes->GetNextChild(node_item, cookie_proc);
        }

        node_item = tree_ctrl_nodes->GetNextChild(root, cookie_node);
    }

}

void CPMGFrame::post_refresh()
{
    wxCommandEvent* e = new wxCommandEvent(wxEVT_COMMAND_BUTTON_CLICKED, wxID_HIGHEST + wxID_button_refresh);
    wxTheApp->GetTopWindow()->GetEventHandler()->QueueEvent(e);
}

void CPMGFrame::show_objects()
{
    if (show_objects_)
    {
        refresh_objects_ = true;
        fill_tree(current_settings_);
        refresh_objects_ = false;
        button_show_objects->SetLabel(hide_objects_string.c_str());
        show_objects_ = false;
    }
    else
    {
        hide_objects();
        button_show_objects->SetLabel(show_objects_string.c_str());
        show_objects_ = true;
    }
}

void CPMGFrame::quit(wxCloseEvent& event)
{
    m_pTimer->Stop();
    cpmd_connection_test_done_once_ = false;

    save_options(true);

    this->Destroy();
}

bool CPMGFrame::get_unavailable(
        ::ICPM_module::UnavailableElementIDSeq & nodes,
        ::ICPM_module::UnavailableElementIDSeq & processes)
{
    // Here, the timeout is no more necessary since we fixed CPMM::check().
    // This fix is to protect unavailable_nodes/unavailable_processes_
    // after the ping.

    const int timeout = 3000;

    // If get_unavailable is called for the first time and
    // that call is due to be a failure, we need a value for 
    // last_get_unavailable_.
    static bool first_call = true; 
    if (first_call)
    {
        last_get_unavailable_ = ACE_OS::gettimeofday();
        first_call = false;
    }

    static bool collapsed(false);

    try
    {
        ::ICPM_module::UnavailableElementIDSeq_var nodes_var;
        ::ICPM_module::UnavailableElementIDSeq_var processes_var;
        if (cpmm_obj_->get_unavailable(nodes_var, processes_var))
        {
            nodes = nodes_var;
            processes = processes_var;
            if (collapsed)
            {
                tree_ctrl_nodes->ExpandAll();
                collapsed = false;
            }
            last_get_unavailable_ = ACE_OS::gettimeofday();
        }
        else
        {
            long diff = (ACE_OS::gettimeofday() - last_get_unavailable_).get_msec();

            if (diff > timeout)
            {
                report("Can't get unavailable nodes/processes. Can't draw tree completely.");
                //tree_ctrl_nodes->CollapseAll();
                collapsed = true;
            }
            return false;
        }
    }
    catch(...)
    {
        long diff = (ACE_OS::gettimeofday() - last_get_unavailable_).get_msec();

        if (diff > timeout)
        {
            report("CPMM seems to be unreachable (unable to get unavailable nodes/processes).");
            //tree_ctrl_nodes->CollapseAll();
            collapsed = true;
        }
        return false;
    }

    last_get_unavailable_ = ACE_OS::gettimeofday();

    return true;
}

bool CPMGFrame::test_cpmd_connection()
{
    std::string current_node = CPMUtils_ns::CPMUtils::get_local_addr();

    std::string location("corbaloc:iiop:");
    location += current_node + ":";

    std::string env_var("CPMD_PORT");
    char * pPort = getenv (env_var.c_str());
    if (!pPort)
    {
        report("Environment variable 'CPMD_PORT' not defined.");
        return false;
    }

    location += std::string(pPort) + "/" + "CPMDObj";

    int prev = CPMTAOLAYER->set_connection_timeout_orb(100);

    CPMTAOLayer::GetRefStatus status;
    ICPM_module::ICPMD_var cpmd = CPMTAOLAYER->get_ref_from_iortable<ICPM_module::ICPMD>(location.c_str(), status, 1, 0);

    CPMTAOLAYER->set_connection_timeout_orb(prev);

    if (!cpmd)
    {
        return false;
    }

    return true;
}

bool CPMGFrame::save_options(bool ask_user)
{
    wxString options;

    bool cpmm = checkbox_console_cpmm->GetValue();
    bool cpmd = checkbox_console_cpmd->GetValue();
    if (cpmm != show_cpmm_console_init_
        || cpmd != show_cpmd_console_init_)
    {
        options += "   - Show consoles\n";
    }

    bool overwrite_autostart_to_false = checkbox_overwrite_auto_start_to_false->GetValue();
    if (overwrite_autostart_to_false != overwrite_autostart_to_false_)
    {
        options += "   - Overwrite autostart_to_false\n";
    }

    if (!options.empty())
    {
        bool go(false);
        if (ask_user)
        {
            wxString msg = wxString::Format("Options changed.\n\n%s\nDo you want to save them?", options);

            int rc = wxMessageBox(
                        msg,
                        "Quit",
                        wxYES_NO | wxICON_WARNING);
            if (rc == wxYES)
            {
                go = true;
            }
        }
        else
        {
            go = true;
        }

        if (go)
        {
            if (!CPMUtils_ns::CPMUtils::save_cpm_params(cpmm, cpmd, overwrite_autostart_to_false))
            {
                wxMessageBox("Can't save cpm parameters.");
                return false;
            }

            checkbox_console_cpmm->SetValue(cpmm);
            checkbox_console_cpmd->SetValue(cpmd);
            checkbox_overwrite_auto_start_to_false->SetValue(overwrite_autostart_to_false);

            show_cpmm_console_init_ = cpmm;
            show_cpmd_console_init_ = cpmd;
            overwrite_autostart_to_false_ = overwrite_autostart_to_false;
        }
    }

    return true;
}